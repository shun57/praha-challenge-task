# 課題

[インデックスを理解する](https://airtable.com/appPxhCPFYGqqN9YU/tblVlFr2q4lIqDKYc/viwX8r6DpCRp80swL/reck5LkatL77euAc4?blocks=hide)

## 課題1

### インデックスの仕組み

データベースから効率的にデータを探す仕組みに「インデックス(索引)」というものがあります。
インデックスを使うと大量のデータから特定のデータを取得する際の検索パフォーマンス向上を期待できます。
なぜパフォーマンスが向上するかというと、テーブルからデータを検索する際の動作が影響します。
インデックスが設定されていない場合、対象のデータを検索する際にはテーブルの最初から順番に1行ずつデータを探します。
そのため、大量データがある場合、検索に時間がかかります。
しかし、インデックスを作成すると、検索用に整形されたデータがテーブルとは別で作成されます。そして、検索する際にはそのインデックスデータを使うため、速度が向上します。
例えば、図書館をイメージしてください。膨大な本の中から特定の本を探しやすくするために、背表紙に番号が振ってあり、順番に並べられていると思います。この番号がインデックスです。番号によって、探すのが容易になっています。
ただし、インデックスにはデメリットもあります。
インデックスを設定したテーブルデータの更新処理速度が低下することです。別でインデックスデータが作られているため、二重で更新が必要になるからです。
そのため、闇雲に作成するのではなく、どのテーブルのどのカラムに設定するのかは考える必要があるので注意してください。
インデックスを設定した方がいいのは、「項目数/データ数が多い、カラムの値が一意、WHERE句に設定している場合」などです。

### ちゃんとslow query logを調べた？

そもそも全てのSQLクエリが目標の時間内に処理を終えているのかを確認する必要があるため。
slow query logを出力すると、ボトルネックになるSQLを発見でき、適切にインデックスを貼るヒントになる。
闇雲にインデックスを張ってしまうと、そもそも速度向上しなかったり、登録・更新・削除が遅くなる可能性もある。

### カーディナリティとは？

テーブルの特定カラムに格納されるデータの種類の絶対値のこと。例えば１年の日付は365日なので、データで持つとするとカーディナリティは365となる。そして、この絶対値がテーブルのレコードに対して少ない場合はカーディナリティが低いと言われ、多い場合は高いと言われる。インデックスを貼るカラムを検討する際に、カーディナリティが高いカラムに作成する方が効果が高い。一つの目安として、1つの値を特定するときに全体の5%に絞り込めるだけのカーディナリティがあるといいとされる。

### カバリングインデックス

クエリが必要とするカラムを全てインデックスに含むと、インデックスだけ参照すれば良くなるので、テーブルアクセスが不要となる。このようにインデックスだけで検索が完結するようなインデックスをカバリングインデックスという。

[Covering Index で処理が高速化するのを確認する](https://www.softel.co.jp/blogs/tech/archives/5139)

## 課題2

### SELECTクエリ3つと速度

```
①1996年支払い開始の給料の総計
SELECT SUM(salary) FROM employees.salaries where (DATE_FORMAT(from_date, '%Y') = '1996');
```
   - salaryにインデックスを貼る
   - インデックス前：3.25sec
   - インデックス後：0.93sec
<pre>
+----+-------------+----------+------------+-------+---------------+------------+---------+------+---------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys | key        | key_len | ref  | rows    | filtered | Extra                    |
+----+-------------+----------+------------+-------+---------------+------------+---------+------+---------+----------+--------------------------+
|  1 | SIMPLE      | salaries | NULL       | index | NULL          | idx_salary | 4       | NULL | 2526472 |   100.00 | Using where; Using index |
+----+-------------+----------+------------+-------+---------------+------------+---------+------+---------+----------+--------------------------+
</pre>
```
②給料が9万ドル以上の社員名
SELECT E.first_name, E.last_name FROM employees.employees AS E INNER JOIN employees.salaries AS S ON E.emp_no = S.emp_no WHERE S.salary > 90000;
```
   - salaryにインデックスを貼る
   - インデックス前：9.27sec
   - インデックス後：1.23sec
<pre>
+----+-------------+-------+------------+--------+--------------------+------------+---------+--------------------+--------+----------+--------------------------+
| id | select_type | table | partitions | type   | possible_keys      | key        | key_len | ref                | rows   | filtered | Extra                    |
+----+-------------+-------+------------+--------+--------------------+------------+---------+--------------------+--------+----------+--------------------------+
|  1 | SIMPLE      | S     | NULL       | range  | PRIMARY,idx_salary | idx_salary | 4       | NULL               | 470064 |   100.00 | Using where; Using index |
|  1 | SIMPLE      | E     | NULL       | eq_ref | PRIMARY            | PRIMARY    | 4       | employees.S.emp_no |      1 |   100.00 | NULL                     |
+----+-------------+-------+------------+--------+--------------------+------------+---------+--------------------+--------+----------+--------------------------+
</pre>
```
SELECT salary FROM employees.salaries WHERE from_date = '2000-09-17';
```
   - from_dateにインデックスを貼る
   - インデックス前：3.59sec
   - インデックス後：0.02sec
<pre>
+----+-------------+----------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra |
+----+-------------+----------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | salaries | NULL       | ref  | idx_from_date | idx_from_date | 3       | const |  691 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
</pre>

## 課題3

### 実装（INSERT)
    
- index付き(to_date, from_date, salary)

```
insert into salaries values (99999, 99999, '2021-01-01', '2021-01-01');
Query OK, 1 row affected (0.45 sec)
```

- index削除

```
insert into salaries values (99999, 99999, '2023-01-01', '2023-01-01');
Query OK, 1 row affected (0.01 sec)
```

- 結果

インデックスがあればあるほどINSERTが遅くなる。テーブルにレコードを追加するだけでなく、全てのインデックスも更新する必要があるため。<br>
[インデックスを作れば作るほど、INSERTが遅くなる](https://use-the-index-luke.com/ja/sql/dml/insert)

### クイズ

1. 各従業員ごとに最大の給料(salary)と従業員名を取得する
2. 従業員の中で最大の給料と従業員名を１つ取得する
3. 入社年月ごとの従業員数を取得する
