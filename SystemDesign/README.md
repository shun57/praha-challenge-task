# 基本的な設計原則

[課題内容](https://airtable.com/appPxhCPFYGqqN9YU/tblVlFr2q4lIqDKYc/viwX8r6DpCRp80swL/rec4LYaRJr7WFOSrA?blocks=hide)

## 課題1

### SOLID原則とは？

#### S:単一責任の原則

1つのクラスは単一の責任を持つべきという原則。責任を持つというのは1機能のみを提供するように分割すべきとも言える。
複数の機能を持つ場合、1機能に変更を加える際に他の機能にも影響を与える可能性が高くなってしまい、バグが発生してしまう確率が増える。

#### O：開放閉鎖(オープン・クローズド)の原則

クラスは、拡張にはオープンで、変更にはクローズドであるべきという原則。
クラスの変更とはそのクラスの責任を修正することを意味し、そういった変更を行うと、そのクラスを使用するすべての機能に影響を与えてしまう。
ただし、既存機能を拡張する場合は、他への影響が少なくなりバグ発生を避けることができる。
例えば、走るという機能を持ったクラスを飛ぶという機能を持ったクラスに変更してはならず、走るかつ飛ぶクラスを持ったクラスに拡張するべきということ。

#### L：リスコフの置換原則

子クラスは親クラスと置換可能であるべきという原則。
「子クラスの振る舞いについての原則」で、親クラスのルールを破ってしまうとクラス間の一貫性がなくなり、バグが生まれやすくなったり、拡張しづらくなってしまう。

#### I：インターフェース分離の原則

クライアントに、クライアントが利用しないインターフェースへの依存を強制すべきではないという原則。
不要な場合は削除したり、分離することで、各クライアントは自分が必要なインターフェースだけに依存することになるため、他のクライアントの変更影響を最小限に抑えることができる。
もし利用しないインターフェースに依存していると、その不要なインターフェースに対する変更がクライアントにまで影響を及ぼしてしまう可能性がある。


#### D：依存性逆転の原則

上位モジュール(使う側)は下位モジュール(使われる側）に依存してはならない、どちらも抽象化に依存すべきであるという原則。また、実装の詳細が抽象に依存すべきである。
例えばクラスAがクラスBの機能を使っている（依存している）場合、依存関係を逆転するためには間にクラスBのインターフェースを実装することで、依存性を逆転できる。
こうした場合、クラスBを変更したくなったとしてもクラスAを意識することなく修正できる。

#### メリット

保守性・拡張性のある設計ができるようになり、メンテナンスしやすいソフトウェア開発ができること。

### 単一責任の原則と単にファイルを分離することの違い

- 単一責任の原則とは、「クラスには１つの責任（１つのアクター）」という原則のため、単にファイルを分割することとは目的が異なる
- ファイルを分離するだけでは責任(アクター)の分割にはならないため
- 例えばファイルを分離するだけの場合は、単一責任内のクラスも分離してしまう可能性があったり、別責任のクラスが混ざる可能性もある。その場合、変更が入った際に複数ファイルを修正する必要が出てしまう可能性がありバグにつながりやすくなってしまう。

#### 参考

https://www.ogis-ri.co.jp/otc/hiroba/others/OOcolumn/single-responsibility-principle.html

### Open-Closed-Principle実例

```
interface IPaymentService {
    pay(): string
}

class Convenience implements IPaymentService {
    pay = () => 'receipt'
}

class CreditCard implements IPaymentService {
    pay = () => 'payment detail'
}

const Payment = (payment: IPaymentService) => {
    console.log(payment.pay())
}

Payment(new CreditCard())
```

### リスコフの置換原則に違反した場合

違反した場合、子クラスが増えた際に、利用するクライアント側でその子クラスの処理を知って利用しなければならなくなる。
また、増えれば増えるほど全ての子クラスの中身を知っていなければいけなくなってしまうため、予期しないバグが発生する可能性が高くなる。

### インターフェースの設計上のメリット

- クラス同士を疎結合にすることができ、変更しやすくなる
- 実装クラスにメソッドの実装を強制することができ、意図しない実装を防げる
- クラスへのアクセスを制限できるため、意図しない利用を防げる

#### 参考

https://qiita.com/yutorisan/items/d28386f168f2f3ab166d

### 依存性の逆転を用いる必要があるケース

- 外部モジュール(下位)を利用するクラスのテストをしたい場合、モックを使うなど付け替えやすいため依存性の逆転を用いる
- 依存(下位)モジュールの変更可能性が高い場合、変更しやすくするために依存性の逆転を用いる

### デメテルの法則とは？

任意のオブジェクトが自分以外の構造やプロパティへの知識（アクセス）を最小限にすべきであるとする法則のこと。
例えば、「親クラス.子クラス.子クラスのメソッド」のように１つ隔たっているクラスのメソッドを呼び出しているとき、その子クラスとも結合が生じるため、メンテナンスが難しくなっていってしまう(その子クラスのメソッド修正が影響する)。
デメテルの法則を守ることで、結合度が低くなり、テストのしやすさや改修のしやすい設計をすることができる。

#### なぜ効果がないのか？

どちらにせよ呼び出す際にPurchaseのget/setなどの内部構造を知っておく必要があるため、結合度が変わっていないため保守性に対して効果がない。例えば呼び出し時にuser_idやproduct_idに何を設定しなければいけないのかを知っている必要がある。


#### デメテルの法則を守ることでどのような意味効果があるか？ペアと話し合ってみよう！


#### 参考

https://tech-blog.rakus.co.jp/entry/20200701/programming


## 課題2

- purchaseメソッドに購入制限と購入手続の2機能が含まれているため、単一責任の原則に反し、各機能の改修がメソッド全体に影響を及ぼす
- 特定の商品だけという制限が加えられていないため、全ての商品が1つ限定になってしまっている
- ロジックに年間1つという制限が加えられていない(もしくはメソッド名から不明)ため、1年以上経っても商品を買えない
- 過去の購入履歴を全て取得してから購入商品を探しているため、購入量が多い場合に性能が落ちる

### 改善案

- purchaseでは購入のみを行い、purchaseを呼び出す前に、限定商品かを確認する
- 仕様はドメインの重要ルールであるため、サービスには記述しない。ドメインに記述してしまうとリポジトリの操作が必要になってしまうためそれも避ける。そのため仕様クラスを作る。
- 一度全ての購入履歴を取得する必要はあるが、１ユーザの購入履歴が多くなりすぎる懸念がないと仮定し、問題ないとする（サービスによるが、、、）

```
interface Purchase {
  userId: string
  productId: string
  transaction: {
    succeeded: true
    completedAt: Date
  }
}

interface PaymentRecordRepo {
  getPurchasesBy: (userId: string) => Purchase[]
}

class PurchaseService {
  public constructor(private paymentRecordRepo: PaymentRecordRepo) {}

  public purchase(userId: string, productId: string) {
    const purchaseLimitSpecification = new PurchaseLimitSpecification(this.paymentRecordRepo)
    if (purchaseLimitSpecification.isPurchasedBy(userId, productId)) {
        throw new Error('この商品はおひとりさま一品限定です！')
    }
    // 購入手続きに進む
  }
}

// 仕様クラス
class PurchaseLimitSpecification {
    public constructor(private paymentRecordRepo: PaymentRecordRepo) {}

    public isPurchasedBy(userId: string, productId: string) {
        const allPurchases = this.paymentRecordRepo.getPurchasesBy(userId)
        const pastPurchase = allPurchases.find((p) => p.productId === productId && p.transaction.succeeded)
        return pastPurchase
    }
}
```

## 課題3

名前と勤務開始日に意図しない値が入ってしまう可能性があり、バグに繋がってしまう。
Personクラスの名前を勤務開始日のプロパティをprivateとすることで意図しない変更を防ぐ。


## 任意課題

### 凝集度

モジュール内の要素の関連性の強さを示す指標で、強いほどいい設計とされる。

- 偶発的凝集
関連性がない処理がまとまっている

- 論理的凝集
論理的に似ている処理がまとまっている（関連ない処理をフラグで切り替える等）

- 時間的凝集
機能的に関連はないが、特定の時間に実行される処理がまとまっている  
※例外発生->ファイルクローズ->エラーログ作成など

- 手続的凝集
機能的に関連はないが、特定の時間でかつ、実行順序に意味のある処理がまとまっている  
※ファイルパーミッションチェック->ファイルオープンなど

- 通信的凝集
機能的に関連はないが、手順に意味があり、手順間で同じ値を利用する処理がまとまっている

- 逐次的凝集
機能的に関連はないが、特定の手順でかつ、手順間で値の受け渡しをする処理がまとまっている

- 機能的凝集
単一の機能のみの処理

### 結合度

２つのモジュール間の結合度の強さを示し、弱いほどいい設計と言われる。

- 内部結合
他の関数と外部宣言されていない値で結合されている（あるモジュールが別モジュールの内部実装に依存している）

- 共通結合
共通のグローバルモジュールで結合されている

- 外部結合
単一のグローバルモジュール（外部ライブラリなど）を参照している

- 制御結合
利用する側の関数が利用される側の操作をフラグで指示することで結合している(引数の種類によって処理が変わる)

- スタンプ結合
構造体やクラスなどを引数で受け渡している

- データ結合
スカラー型の受け渡しで結合している

- メッセージ結合
関数の実行で結合し、値の受け渡しは存在しない


#### 参考

- 凝集度
https://fortee.jp/object-oriented-conference-2020/proposal/a826b6c6-167c-4c5c-bfc7-52bb8bc22ec1


- 結合度
https://zenn.dev/taiga533/articles/e08ad4f4af5577079b5b